《算法设计与分析基础（第3版 详解版）》
ISBN9787302625445

作者基于丰富的教学经验，开发了一套全新的算法分类方法。该分类法站在通用问题求解策略的高度，对现有大多数算法准确分类，从而引领读者沿着一条清晰、一致、连贯的思路来探索算法设计与分析这一迷人领域。《算法设计与分析基础（第3版 详解版）》作为第3版，相对前版调整了多个章节的内容和顺序，同时增加了一些算法，并扩展了算法的应用，使得具体算法和通用算法设计技术的对应更加清晰有序；各章累计增加了70道习题，其中包括一些有趣的谜题和面试问题。

《算法设计与分析基础（第3版 详解版）》十分适合用作算法设计和分析的基础教材，也适合任何有兴趣探究算法奥秘的读者使用，只要读者具备数据结构和离散数学的知识即可。

详细目录
第1章　导言
1.1　什么是算法
习题1.1
1.2　算法问题求解基础
1.2.1  理解问题
1.2.2  了解计算设备的性能
1.2.3  在精确和近似解法之间做出选择
1.2.4  算法的设计技术
1.2.5  设计算法和数据结构
1.2.6  算法描述方法
1.2.7  算法的正确性证明
1.2.8  分析算法
1.2.9  为算法写代码
习题1.2
1.3　重要的问题类型
1.3.1  排序
1.3.2  查找
1.3.3  字符串处理
1.3.4  图问题
1.3.5  组合问题
1.3.6  几何问题
1.3.7  数值问题
习题1.3
1.4　基本数据结构
1.4.1  线性数据结构
1.4.2  图
1.4.3  树
1.4.4  集合与字典
习题1.4
本章要点小结
第2章　算法效率分析基础
2.1　分析框架
2.1.1  度量输入规模
2.1.2  运行时间的度量单位
2.1.3  增长量级
2.1.4  算法的最差、最优和平均效率
2.1.5  分析框架概要
习题2.1
2.2　渐近符号和基本效率类型
2.2.1  非正式的介绍
2.2.2  符号O
2.2.3  符号Ω
2.2.4  符号Θ
2.2.5  渐近符号的有用特性
2.2.6  利用极限比较增长量级
2.2.7  基本效率类别
习题2.2
2.3  非递归算法的数学分析
习题2.3
2.4  递归算法的数学分析
习题2.4
2.5　例题：计算第n个斐波那契数
习题2.5
2.6　算法的经验分析
习题2.6
2.7　算法可视化
本章要点小结
第3章　蛮力法
3.1　选择排序和冒泡排序
3.1.1  选择排序
3.1.2  冒泡排序
习题3.1
3.2　顺序查找和蛮力字符串匹配
3.2.1  顺序查找
3.2.2  蛮力字符串匹配
习题3.2
3.3　最近对和凸包问题的蛮力算法
3.3.1  最近对问题
3.3.2  凸包问题
习题3.3
3.4　穷举查找
3.4.1  旅行商问题
3.4.2  背包问题
3.4.3  分配问题
习题3.4
3.5　深度优先查找和广度优先查找
3.5.1  深度优先查找
3.5.2  广度优先查找
习题3.5
本章要点小结
第4章　减治法
4.1　插入排序
习题4.1
4.2　拓扑排序
习题4.2
4.3  生成组合对象的算法
4.3.1  生成排列
4.3.2  生成子集
习题4.3
4.4  减常因子算法
4.4.1  折半查找
4.4.2  假币问题
4.4.3  俄式乘法
4.4.4  约瑟夫斯问题
习题4.4
4.5　减可变规模算法
4.5.1  计算中值和选择问题
4.5.2  插值查找
4.5.3  二叉查找树的查找和插入
4.5.4  尼姆游戏
习题4.5
本章要点小结
第5章　分治法
5.1　合并排序
习题5.1
5.2　快速排序
习题5.2
5.3　二叉树遍历及其相关特性
习题5.3
5.4　大整数乘法和Strassen矩阵乘法
5.4.1  大整数乘法
5.4.2  Strassen矩阵乘法
习题5.4
5.5　用分治法解最近对问题和凸包问题
5.5.1  最近对问题
5.5.2  凸包问题
习题5.5
本章要点小结
第6章　变治法
6.1　预排序
习题6.1
6.2　高斯消去法
6.2.1  LU分解
6.2.2  计算矩阵的逆
6.2.3  计算矩阵的行列式
习题6.2
6.3　平衡查找树
6.3.1  平衡二叉查找树
6.3.2  2-3树
习题6.3
6.4　堆和堆排序
6.4.1  堆的概念
6.4.2  堆排序
习题6.4
6.5　霍纳法则和二进制幂
6.5.1  霍纳法则
6.5.2  二进制幂
习题6.5
6.6　问题化简
6.6.1  求最小公倍数
6.6.2  计算图中的路径数量
6.6.3  最优化问题的化简
6.6.4  线性规划
6.6.5  简化为图问题
习题6.6
本章要点小结
第7章　时空权衡
7.1　计数排序
习题7.1
7.2　字符串匹配中的输入增强技术
7.2.1　Horspool算法
7.2.2　Boyer-Moore算法
习题7.2
7.3　散列法
7.3.1　开散列(分离链)
7.3.2　闭散列(开式寻址)
习题7.3
7.4　B树
习题7.4
本章要点小结
第8章　动态规划
8.1　三个基本例子
习题8.1
8.2　背包问题和记忆功能
8.2.1  背包问题
8.2.2　记忆功能
习题8.2
8.3　最优二叉查找树
习题8.3
8.4　Warshall算法和Floyd算法
8.4.1　Warshall算法
8.4.2　计算完全最短路径的Floyd算法
习题8.4
本章要点小结
第9章　贪婪技术
9.1　Prim算法
习题9.1
9.2　Kruskal算法
习题9.2
9.3　Dijkstra算法
习题9.3
9.4　哈夫曼树及编码
习题9.4
本章要点小结
第10章　迭代改进
10.1　单纯形法
10.1.1  线性规划的几何解释
10.1.2  单纯形法概述
10.1.3  单纯形法其他要点
习题10.1
10.2　最大流量问题
习题10.2
10.3　二分图的最大匹配
习题10.3
10.4　稳定婚姻问题
习题10.4
本章要点小结
第11章　算法能力的极限
11.1　如何求下界
11.1.1　平凡下界
11.1.2　信息论下界
11.1.3　敌手下界
11.1.4　问题化简
习题11.1
11.2　决策树
11.2.1　排序的决策树
11.2.2　查找有序数组的决策树
习题11.2
11.3　P、NP和NP完全问题
11.3.1　P和NP问题
11.3.2　NP完全问题
习题11.3
11.4　数值算法的挑战
习题11.4
本章要点小结
第12章　应对算法能力的极限
12.1　回溯法
12.1.1　n皇后问题
12.1.2　哈密顿回路问题
12.1.3　子集和问题
12.1.4　概括性说明
习题12.1
12.2　分支定界法
12.2.1　分配问题
12.2.2　背包问题
12.2.3　旅行商问题
习题12.2
12.3　NP难题的近似算法
12.3.1　旅行商问题的近似算法
12.3.2　背包问题的近似算法
习题12.3
12.4　解非线性方程的算法
12.4.1　对分法
12.4.2　试位法
12.4.3　牛顿法
习题12.4
本章要点小结
后记
附录A　算法分析的实用公式
附录B　递推关系简明指南
参考文献

Table of Contents
New tothe Third Edition xvii
Prefacexix
1 Introduction 
1.1 WhatIs an Algorithm? 
Exercises 1.1 
1.2 Fundamentals of Algorithmic Problem Solving 
Understanding the Problem 
Ascertaining the Capabilities of the Computational Device 
Choosing between Exact and Approximate Problem Solving 
Algorithm Design Techniques 
Designingan Algorithm and Data Structures 
Methods of Specifying an Algorithm 
Proving an Algorithm's Correctness 
Analyzing an Algorithm 
Coding an Algorithm 
Exercises 1.2 
1.3 Important Problem Types 
Sorting 
Searching 
String Processing 
Graph Problems 
Combinatorial Problems 
Geometric Problems 
Numerical Problems 
Exercises 1.3 
1.4 Fundamental Data Structures 
Linear Data Structures 
Graphs 
Trees 
Sets and Dictionaries 
Exercises 1.4 
Summary 
2 Fundamentals of the Analysis of Algorithm Efficiency 
2.1 The Analysis Framework 
Measuring an Input's Size 
Units for Measuring Running Time 
Orders of Growth 
Worst-Case, Best-Case, and Average-Case Efficiencies 
Recapitulation of the Analysis Framework 
Exercises 2.1 
2.2 Asymptotic Notations and Basic Efficiency Classes 
Informal Introduction 
O-notation 
Ω-notation 
Θ-notation
Useful Property Involving the Asymptotic Notations 
Using Limits for Comparing Orders of Growth 
Basic Efficiency Classes 
Exercises 2.2 
2.3 Mathematical Analysis of Nonrecursive Algorithms 
Exercises 2.3 
2.4 Mathematical Analysis of Recursive Algorithms 
Exercises 2.4 
2.5 Example: Computing the nth Fibonacci Number 
Exercises 2.5 
2.6 Empirical Analysis of Algorithms 
Exercises 2.6 
2.7Algorithm Visualization 
Summary 
3 Brute Force and Exhaustive Search 
3.1 Selection Sort and Bubble Sort 
SelectionSort 
Bubble Sort 
Exercises 3.1 
3.2 Sequential Search and Brute-Force String Matching 
Sequential Search 
Brute-Force String Matching 
Exercises 3.2 
3.3 Closest-Pair and Convex-Hull Problems by BruteForce 
Closest-Pair Problem 
Convex-Hull Problem 
Exercises 3.3 
3.4 Exhaustive Search 
Traveling Salesman Problem 
Knapsack Problem 
Assignment Problem 
Exercises 3.4 
3.5 Depth-First Search and Breadth-First Search 
Depth-First Search 
Breadth-First Search 
Exercises 3.5 
Summary 
4 Decrease-and-Conquer 
4.1 Insertion Sort 
Exercises 4.1 
4.2 Topological Sorting 
Exercises 4.2 
4.3 Algorithms for Generating Combinatorial Objects 
Generating Permutations 
Generating Subsets 
Exercises 4.3 
4.4 Decrease-by-a-Constant-Factor Algorithms 
Binary Search 
Fake-CoinProblem 
Russian Peasant Multiplication 
Josephus Problem 
Exercises 4.4 
4.5 Variable-Size-Decrease Algorithms 
Computinga Median and the Selection Problem 
Interpolation Search 
Searching and Insertion in a Binary Search Tree 
The Game of Nim 
Exercises 4.5 
Summary 
5 Divide-and-Conquer 
5.1 Mergesort 
Exercises 5.1 
5.2 Quicksort 
Exercises 5.2 
5.3 Binary Tree Traversals and Related Properties 
Exercises 5.3 
5.4 Multiplication of Large Integers and Strassen's Matrix Multiplication 
Multiplication of LargeIntegers 
Strassen's Matrix Multiplication 
Exercises 5.4 
5.5 The Closest-Pair and Convex-Hull Problems by Divide-and-Conquer 
The Closest-Pair Problem 
Convex-Hull Problem 
Exercises 5.5 
Summary 
6 Transform-and-Conquer 
6.1 Presorting 
Exercises 6.1 
6.2 Gaussian Elimination 
LU Decomposition 
Computing a Matrix Inverse 
Computing a Determinant 
Exercises 6.2 
6.3 Balanced Search Trees 
AVL Trees 
2-3 Trees 
Exercises 6.3 
6.4 Heaps and Heapsort 
Notion ofthe Heap 
Heapsort 
Exercises 6.4 
6.5 Horner's Rule and Binary Exponentiation 
Horner's Rule 
Binary Exponentiation 
Exercises 6.5 
6.6 Problem Reduction 
Computing the Least Common Multiple 
Counting Paths in a Graph 
Reduction of Optimization Problems 
Linear Programming 
Reduction to Graph Problems 
Exercises 6.6 
Summary 
7 Space and Time Trade-Offs 
7.1 Sorting by Counting 
Exercises7.1 
7.2 Input Enhancement in String Matching 
Horspool's Algorithm 
Boyer-Moore Algorithm 
Exercises 7.2 
7.3 Hashing 
Open Hashing (Separate Chaining) 
Closed Hashing (Open Addressing) 
Exercises 7.3 
7.4 B-Trees 
Exercises 7.4 
Summary 
8 Dynamic Programming 
8.1 Three Basic Examples 
Exercises 8.1 
8.2 The Knapsack Problem and Memory Functions 
Memory Functions 
Exercises 8.2 
8.3 Optimal Binary Search Trees 
Exercises 8.3 
8.4 Warshall's and Floyd's Algorithms 
Warshall's Algorithm 
Floyd's Algorithm for the All-Pairs Shortest-Paths Problem 
Exercises 8.4 
Summary 
9 Greedy Technique 
9.1 Prim's Algorithm 
Exercises 9.1 
9.2 Kruskal's Algorithm 
Disjoint Subsets and Union-Find Algorithms 
Exercises 9.2 
9.3 Dijkstra's Algorithm 
Exercises 9.3 
9.4 Huffman Trees and Codes 
Exercises 9.4 
Summary 
10 Iterative Improvement 
10.1 The Simplex Method 
Geometric Interpretation of Linear Programming 
An Outline of the Simplex Method 
Further Notes on the Simplex Method 
Exercises 10.1 
10.2 TheMaximum-Flow Problem 
Exercises 10.2 
10.3 Maximum Matching in Bipartite Graphs 
Exercises 10.3 
10.4 The Stable Marriage Problem 
Exercises 10.4 
Summary 
11 Limitations of Algorithm Power 
11.1 Lower-Bound Arguments 
Trivial Lower Bounds 
Information-Theoretic Arguments 
Adversary Arguments 
Problem Reduction 
Exercises 11.1 
11.2 Decision Trees 
Decision Trees for Sorting 
Decision Trees for Searching a Sorted Array 
Exercises 11.2 
11.3 P,NP, and NP-Complete Problems 
P and NPProblems 
NP-Complete Problems 
Exercises 11.3 
11.4 Challenges of Numerical Algorithms 
Exercises 11.4 
Summary 
12 Copingwith the Limitations of Algorithm Power 
12.1 Backtracking 
n-QueensProblem 
Hamiltonian Circuit Problem 
Subset-Sum Problem 
General Remarks 
Exercises 12.1 
12.2 Branch-and-Bound 
Assignment Problem 
Knapsack Problem 
Traveling Salesman Problem 
Exercises 12.2 
12.3 Approximation Algorithms for NP-Hard Problems 
Approximation Algorithms for the Traveling Salesman Problem 
Approximation Algorithms for the Knapsack Problem 
Exercises 12.3 
12.4 Algorithms for Solving Nonlinear Equations 
Bisection Method 
Method of False Position 
Newton's Method 
Exercises 12.4 
Summary 
Epilogue 
APPENDIXA
Useful Formulas for the Analysis of Algorithms 
Properties of Logarithms 
Combinatorics 
Important Summation Formulas 
Sum Manipulation Rules 
Approximation of a Sum bya Definite Integral 
Floor and Ceiling Formulas 
Miscellaneous 
APPENDIXB
Short Tutorial on Recurrence Relations 
Sequencesand Recurrence Relations 
Methods for Solving Recurrence Relations 
Common Recurrence Types in Algorithm Analysis 
References 
Hints toExercises 
Index